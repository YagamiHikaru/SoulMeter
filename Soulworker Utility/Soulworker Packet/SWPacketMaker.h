#pragma once
#include ".\Soulworker Packet\PacketType.h"

#define SWPACKETMAKER SWPacketMaker::getInstance()

#define NO_SEGMENTATION 0
#define YES_SEGMENTATION 1
#define REASSAMBLY 2
#define NO_SWHEADER 3
#define NO_SWDATA 4
#define SEGMENTATION_SUCCESS 5
#define SEGMENTATION_FAILED 6

#define DEBUG_SEGMENTATION 0
#define DEBUG_CREATEPACKET 0
#define DEBUG_RESIZEPACKET 0
#define DEBUG_PRINTOPCODE 0

class SWPacketMaker : public Singleton<SWPacketMaker> {
private:
	class SegmentationPacket {
	private:
		BYTE* _data;
		SIZE_T _size;

		SIZE_T _curSize;
		SIZE_T _packetSize;

		IPv4Packet _packet;

	public:
		SegmentationPacket() {
			_data = nullptr;
			_size = 0;
			_curSize = 0;
			_packetSize = 0;
		}

		~SegmentationPacket() {

			if (_data != nullptr)
				delete[] _data;

			_data = nullptr;
		}

		VOID Init(SIZE_T size) {

			if (_data == nullptr) {
				_data = new BYTE[size];
				_size = size;
			}

			if (_size < size) {
				delete[] _data;
				_data = new BYTE[size];
				_size = size;
			}

			_curSize = 0;
			_packetSize = size;

#if DEBUG_SEGMENTATION == 1
			Log::WriteLogA(const_cast<CHAR*>("[segmentationPacket Init] [curSize = %d] [packetSize = %d]"), _curSize, _packetSize);
#endif

		}

		SIZE_T GetRemainSize() {
#if DEBUG_SEGMENTATION == 1
			Log::WriteLogA(const_cast<CHAR*>("[segmentationPacket RemainSize = %d]"), _packetSize - _curSize);
#endif

			return _packetSize - _curSize;
		}

		DWORD AppendData(BYTE* data, SIZE_T size) {

			memcpy(_data + _curSize, data, size);

			int temp_debug = _curSize;
			_curSize += size;

#if DEBUG_SEGMENTATION == 1
			Log::WriteLogA(const_cast<CHAR*>("[segmentationPacket AppendData Before curSize = %d After curSize = %d]"), temp_debug, _curSize);

			for (int i = temp_debug; i < _curSize; i++)
				printf("%02x ", _data[i]);
			printf("\n");
#endif

			if (_curSize == _packetSize)
				return SEGMENTATION_SUCCESS;
			else if (_curSize < _packetSize)
				return SEGMENTATION_FAILED;
		}

		IPv4Packet* GetData() {
			_packet._data = _data;
			_packet._datalength = _packetSize;

			return &_packet;
		}
	};

	VOID Decrypt(BYTE* data, const UINT size, const UINT start);

	const BYTE _keyTable[292] = {
		0x86, 0x40, 0x41, 0x20, 0x8C, 0x1A, 0x2E, 0x2C,
		0x30, 0x1E, 0x99, 0xC9, 0x04, 0xE1, 0xD3, 0xD0,
		0x0E, 0xA1, 0x33, 0x0D, 0x7C, 0x29, 0x69, 0x44,
		0x93, 0xF5, 0x0F, 0x71, 0xE9, 0x97, 0x81, 0x54,
		0xD4, 0x59, 0xEF, 0x2D, 0x22, 0x24, 0xB0, 0xC5,
		0x0A, 0xA0, 0xD9, 0xAD, 0x63, 0x9D, 0x0F, 0xCA,
		0x14, 0xB2, 0x99, 0x12, 0xCC, 0x23, 0xB9, 0x90,
		0xF3, 0x08, 0x3D, 0xAE, 0xE0, 0xAC, 0x51, 0xB3,
		0x4C, 0x34, 0x97, 0x8B, 0x06, 0x81, 0x7A, 0xC7,
		0xE9, 0x57, 0xBF, 0xE4, 0x0C, 0xBE, 0x5C, 0xD0,
		0x38, 0xA8, 0x8E, 0xAA, 0x9F, 0xD5, 0x26, 0xC9,
		0xCA, 0xF4, 0x23, 0x01, 0xD4, 0x0B, 0x86, 0x21,
		0xD6, 0x18, 0x62, 0xC0, 0xA2, 0xF9, 0x33, 0x3A,
		0xB4, 0x89, 0x70, 0xF5, 0x65, 0x0C, 0x64, 0xE9,
		0x62, 0xCD, 0x39, 0x5F, 0x5D, 0x05, 0x56, 0xF8,
		0x02, 0xFF, 0xEB, 0xF2, 0x2D, 0x7A, 0xC9, 0xA7,
		0x5A, 0x4F, 0x78, 0x56, 0x5D, 0x53, 0x83, 0x26,
		0x7F, 0x17, 0x68, 0xD8, 0x4E, 0xCC, 0x1D, 0x7A,
		0x67, 0xC3, 0xB8, 0x6E, 0x7C, 0xF1, 0x25, 0x82, 
		0x72, 0xBA, 0x09, 0x53, 0xC2, 0x4C, 0xC0, 0x1F,
		0x00, 0xD5, 0x9E, 0x59, 0x14, 0x94, 0xAD, 0x81,
		0xDA, 0xC6, 0xCB, 0x4E, 0x3F, 0x74, 0x68, 0xBF,
		0x53, 0x3D, 0x3A, 0x02, 0xA0, 0x56, 0x32, 0x95,
		0xBB, 0xCF, 0xAE, 0xAB, 0x18, 0xF0, 0xD1, 0x22,
		0xC3, 0xCF, 0xD1, 0x8B, 0xAC, 0xD6, 0xE1, 0x96,
		0xA8, 0xD2, 0x63, 0xF7, 0x14, 0x1D, 0x12, 0x77,
		0x2A, 0x5F, 0x0B, 0x95, 0xFA, 0xAF, 0x13, 0xCB,
		0xA6, 0xFC, 0x74, 0xD2, 0xAC, 0x08, 0xAA, 0x57, 
		0x84, 0x93, 0x14, 0x37, 0xC8, 0x55, 0x60, 0xD6,
		0xA3, 0xE0, 0xAD, 0x67, 0x28, 0xED, 0xA4, 0x5A,
		0xD9, 0xE9, 0xC2, 0x0A, 0xED, 0x86, 0xA4, 0x7F,
		0x7D, 0x46, 0x4F, 0xFA, 0xD7, 0x11, 0x9E, 0x3A,
		0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x7F, 0xFF,
		0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
		0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF,
		0xFF, 0x00, 0xFF, 0xFF };

	SWHEADER* GetSWHeader(IPv4Packet* packet);
	BYTE* GetSWData(IPv4Packet* packet);

	VOID ResizePacket(IPv4Packet* packet);
	VOID ResizePacket(SIZE_T remainsize, IPv4Packet* packet);

	DWORD CheckSegmentation(IPv4Packet* packet);
	BOOL _isSegmentation;

	VOID StartReassambly(IPv4Packet* packet);
	VOID Reassambly(IPv4Packet* packet);
	SegmentationPacket _segmentationPacket;

	VOID CreateSWPacket(IPv4Packet* packet);

	VOID CheckRemainPacket(IPv4Packet* packet);

public:
	SWPacketMaker();
	~SWPacketMaker();

	DWORD Parse(IPv4Packet* packet);
	int bytesToInt(byte* bytes, int size);
};